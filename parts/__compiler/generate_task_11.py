import numpy as np
import pandas as pd

import settings
from utils import dataframe_to_latex_table, array_2d_to_latex

print(
    r"""\section{Завдання 11}
\begin{itemize}
    \item Використовуючи початковi данi завдання 10, провести класифiкацiю об’єктiв
на два класи методом k-середнiх.
\item Провести класифiкацiю об’єктiв методом пошуку згущень.
\item Надати змiстовну iнтерпретацiю результатам.
\end{itemize}
\subsection{Розв'язання}
Поряд з ієрархічними методами існує група ітеративних методів класифікації. Суть їх полягає в тому, що процес класифікації починається з задання деяких початкових умов (кількості утворених класів, поріг завершення процесу класифікації і тому подібне). Більшість цих методів дуже чутлива до зміни і вибору класифікаційних процедур і задання початкових параметрів. Наприклад, вибрана випадково кількість класів може не тільки сильно збільшити трудомісткість процесу класифікації, але і привести до утворення «розмитих» або мало наповнених класів. Тому доцільно спочатку провести класифікацію одним з ієрархічних методів або за допомогою експертних оцінок, а потім вже підбирати початкове розбиття і статистичний критерій для роботи ітераційного алгоритму. Як і в ієрархічній класифікації, в ітераційних методах існує проблема визначення кількості класів. Не всі ітераційні методи вимагають початкового задання кількості класів. Але для остаточного розв’язання питання про структуру сукупності об’єктів можна використати декілька алгоритмів, змінюючи або число утворених класів, або встановлений поріг близькості для об’єднання об’єктів в класи. Тоді виникає можливість вибрати найкраще розбиття за заданим критерієм якості. \\
\subsubsection{Метод k-середніх}
Метод k-середніх належить до групи ітераційних методів еталонного типу, що орієнтовані на використання принципу «найближчого центру». Перерахунок центру класу може здійснюватися в ході ітерації після кожної зміни складу класу або по завершенні ітерацій. \\
\includegraphics[width = 16cm, height = 13cm]{lab10_3.PNG} \\ \\
Розглянемо 10 об’єктів, які необхідно розбити на два класи за допомогою методу k-середніх. Кожен з об’єктів описується чотирма змінними $x_1, x_2, x_3, x_4.$"""
)

X = settings.task_10_classification_rows
Y = np.array([v - 1 for v in settings.task_10_classification_countries])

df = settings.task_10_table_raw
n = len(df)

print(
    dataframe_to_latex_table(
        df.rename(index={j: f"$n_{{{i}}}$" for i, j in zip(range(10), df.index)}),
        left_top_item="Країна",
    )
)

std = df.std(ddof=1)

df_st = (df - df.mean()) / std

E1 = df_st.loc[Y[0]].values
E2 = df_st.loc[Y[1]].values
w1 = 1
w2 = 1

s1 = set()
s2 = set()
s1_p = set()
s2_p = set()

print(r"\textbf{Iтерація 0:}\\")

print(
    r"За еталони вiзьмемо першi два об’єкти. Запишемо початковi значення еталонiв i ваги:\\"
)

print(
    f"$$\\left\\{{\\begin{{matrix}}"
    f"E_1^0 = n_0 =  ({'; '.join([str(v) for v in np.round(E1, 2)])}), \\; \\; w_1^0 = 1 \\\\ "
    f"E_2^0 = n_1 =  ({'; '.join([str(v) for v in np.round(E2, 2)])}), \\; \\; w_2^0 = 1"
    f"\\end{{matrix}}\\right.$$"
)

print(r"\textbf{Iтерація 1:}\\")
for i in range(2, 10):
    d1 = np.sqrt(((E1 - df_st.loc[Y[i]].values) ** 2).sum())
    d2 = np.sqrt(((E2 - df_st.loc[Y[i]].values) ** 2).sum())
    print(
        f"На {i-1} кроцi 1 iтерацiї розглядаємо об’єкт $n_{i+1}$ i визначаємо його вiдстань до кожного з еталонiв за евклiдовою метрикою: $d_{{{i+1} 0}} = {np.round(d1, 2)}, d_{{{i+1} 1}} = {np.round(d2, 2)}$. \\"
    )
    if d1 <= d2:
        E1 = (w1 * E1 + df_st.loc[Y[i]].values) / (w1 + 1)
        w1 += 1
        s1.add(i)

        print(
            f"$$\\left\\{{\\begin{{matrix}}"
            f"E_1^{i-1} = ({'; '.join([str(v) for v in np.round(E1, 2)])}), \\; \\; w_1^{i-1} = {w1} \\\\ "
            f"E_2^{i-1} = E_2^{i-2} = ({'; '.join([str(v) for v in np.round(E2, 2)])}), \\; \\; w_2^{i-1} = w_2^{i-2} = {w2}"
            f"\\end{{matrix}}\\right.$$"
        )

    else:
        E2 = (w2 * E2 + df_st.loc[Y[i]].values) / (w2 + 1)
        w2 += 1
        s2.add(i)

        print(
            f"$$\\left\\{{\\begin{{matrix}}"
            f"E_1^{i-1} = E_1^{i-2} = ({'; '.join([str(v) for v in np.round(E1, 2)])}), \\; \\; w_1^{i-1} = w_1^{i-2} = {w1} \\\\ "
            f"E_2^{i-1} = ({'; '.join([str(v) for v in np.round(E2, 2)])}), \\; \\; w_2^{i-1} = {w2}"
            f"\\end{{matrix}}\\right.$$"
        )

print(
    r"Перша ітерація закінчена. Отримали такі класи:"
    f"$k_1 = \\{{{', '.join([f'n_{i}' for i in s1|{0}])}\\}},$ $k_2 = \\{{{', '.join([f'n_{i}' for i in s2|{1}])}\\}}$\\\\"
    r"Далі за тим же алгоритмом здійснюється перегляд і приєднання до відповідного еталону кожного з десяти об’єктів. При цьому перераховуються еталони і нарощуються їх ваги. \\"
)

t = 0
iteration_n = 2
while True:
    print(f"\\textbf{{Iтерація {{{iteration_n}}}:}}\\\\")
    s1_p = s1.copy()
    s2_p = s2.copy()
    s1.clear()
    s2.clear()
    t += 1
    for i in range(10):
        d1 = np.sqrt(((E1 - df_st.loc[Y[i]].values) ** 2).sum())
        d2 = np.sqrt(((E2 - df_st.loc[Y[i]].values) ** 2).sum())
        print(
            f"На {i+1} кроцi {iteration_n} iтерацiї розглядаємо об’єкт $n_{i+1}$ i визначаємо його вiдстань до кожного з еталонiв за евклiдовою метрикою: $d_{{{i+1} 0}} = {np.round(d1, 2)}, d_{{{i+1} 1}} = {np.round(d2, 2)}$. \\\\"
        )
        if d1 <= d2:
            E1 = (w1 * E1 + df_st.loc[Y[i]].values) / (w1 + 1)
            w1 += 1
            s1.add(i)
            print(
                f"$$\\left\\{{\\begin{{matrix}}"
                f"E_1^{i+1} = ({'; '.join([str(v) for v in np.round(E1, 2)])}), \\; \\; w_1^{i+1} = {w1} \\\\ "
                f"E_2^{i+1} = E_2^{i} = ({'; '.join([str(v) for v in np.round(E2, 2)])}), \\; \\; w_2^{i+1} = w_2^{i} = {w2}"
                f"\\end{{matrix}}\\right.$$"
            )
        else:
            E2 = (w2 * E2 + df_st.loc[Y[i]].values) / (w2 + 1)
            w2 += 1
            s2.add(i)
            print(
                f"$$\\left\\{{\\begin{{matrix}}"
                f"E_1^{i+1} = E_1^{i} = ({'; '.join([str(v) for v in np.round(E1, 2)])}), \\; \\; w_1^{i+1} = w_1^{i} = {w1} \\\\ "
                f"E_2^{i+1} = ({'; '.join([str(v) for v in np.round(E2, 2)])}), \\; \\; w_2^{i+1} = {w2}"
                f"\\end{{matrix}}\\right.$$"
            )

    print(
        f"{iteration_n} ітерація закінчена. Отримали такі класи:"
        f"$k_1 = \\{{{', '.join([f'n_{i}' for i in s1])}\\}},$ $k_2 = \\{{{', '.join([f'n_{i}' for i in s2])}\\}}$\\\\"
    )
    if s1 == s1_p and s2 == s2_p:
        print(
            f"Так як кроки {iteration_n-1} ітерації дали той же результат, що й кроки {iteration_n} ітерації, то процес закінчено. \\\\"
        )
        break
    else:
        print(
            f"Далі за тим же алгоритмом здійснюється перегляд і приєднання до відповідного еталону кожного з десяти об’єктів. При цьому перераховуються еталони і нарощуються їх ваги. \\\\"
        )
    iteration_n += 1
ss1 = []
ss2 = []
for i in s1:
    ss1.append(i)
for i in s2:
    ss2.append(i)
c1 = (df_st.loc[Y[ss1]]).sum().values / len(ss1)
c2 = (df_st.loc[Y[ss2]]).sum().values / len(ss2)

c = np.zeros((2, 10))
for i in range(10):
    c[0][i] = np.sqrt(((c1 - df_st.loc[Y[i]].values) ** 2).sum())
    c[1][i] = np.sqrt(((c2 - df_st.loc[Y[i]].values) ** 2).sum())

print(r"Розраховуємо центри ваги отриманих класів: \\")
print(f"$$c_1 = ({'; '.join([str(v) for v in np.round(c1, 3)])})$$")
print(f"$$c_2 = ({'; '.join([str(v) for v in np.round(c2, 3)])})$$")
print(
    r"Побудуємо остаточне розбиття: кожен об’єкт віднесемо до того класу, центр якого ближче до об’єкту. Розрахуємо відстані від об’єктів до центрів двох класів:"
)

c = np.round(c, 3)

cdf = pd.DataFrame(
    data={
        "$c_1$": [
            f"\\underline{{{v1}}}" if v1 < v2 else f"{v1}" for v1, v2 in zip(c[0], c[1])
        ],
        "$c_2$": [
            f"\\underline{{{v2}}}" if v2 < v1 else f"{v2}" for v1, v2 in zip(c[0], c[1])
        ],
    },
    index=[f"$n_{{{i}}}$" for i in range(10)],
)

print(dataframe_to_latex_table(cdf))

print(
    r"""Підкреслені числа – це найменші відстані від об’єктів до центру класів.\\
Отримано ті самі класи.
\subsection{Висновок}
Метод k-середніх це популярний метод кластеризації, в якому проводиться впорядкування множини об'єктів в порівняно однорідні групи. \\
Мета методу — розділити n спостережень на k кластерів, так щоб кожне спостереження належало до кластера з найближчим до нього середнім значенням. Метод базується на мінімізації суми квадратів відстаней між кожним спостереженням та центром його кластера. Перевагами цього методу є простота використання; швидкість використання;
зрозумілість і прозорість алгоритму.
\subsubsection{Метод пошуку згущень}
Цей метод класифікації також відноситься до ітераційних методів. Він не вимагає задання кількості класів. Існує декілька модифікацій цього методу. Вони відрізняються початковим станом і критерієм завершення класифікації. Детально розглянемо один із методів пошуку згущень, який має назву «ФОРЕЛ», формалізація елементів, або, як його інколи називають, «форель». Метод використовує деякого радіусу гіперсферу, що переміщується в просторі класифікаційних ознак з метою пошуку локальних згущень об’єктів.\\
Розглядається матриця відстаней (або подібності) між об’єктами. Вибирається об’єкт, який є початковим центром першого класу. Вибір такого об’єкту може бути довільним, а може ґрунтуватися на попередньому аналізі точок і їх околів. Другий підхід значно швидше призводить до розподілу об’єктів по
класах.\\
Обраний об’єкт приймається за центр гіперсфери заданого радіусу $R.$ Визначається сукупність точок, що потрапила до цієї сфери, і для них обчислюються координати центру ваги (вектор середніх значень ознак). Далі знову розглядаємо гіперсферу такого ж радіусу, але з новим центром, і для сукупності точок, що потрапили до неї, знову перераховується вектор середніх значень ознак, який і приймається за новий центр сфери. Коли черговий перерахунок координат центру сфери призводить до такого ж результату, як і на
попередньому кроці, то переміщення сфери призупиняється. Об’єкти, що потрапили до сфери, утворюють клас і з подальшого розгляду виключаються. Для всіх інших точок, що не потрапили до класу, процедура пошуку згущень повторюється при тому ж самому радіусу сфери $R.$ Процес завершується, коли всі об’єкти будуть розподілені по класах.\\
Класифікація завершується за скінченне число кроків. Число утворених класів наперед невідоме і дуже залежить від вибору радіусу сфери.\\
Для оцінки стійкості отриманого розбиття доцільно повторити процес класифікації декілька разів для різних значень радіусу сфери, кожен раз змінюючи радіус на невелику величину. \\
Радіус сфери можна обирати таким чином:\\
а) якщо $d_{ij}$ – відстань між $i$-м і $j$-м об’єктами, то за нижню межу радіусу $R$ можна брати $R_H = \min_{i,j}\{d_{ij}\}$, а за верхню – $R_B = \max_{i,j}\{d_{ij}\}$. Тоді $R_H < R < R_B;$\\
б) можна починати алгоритм з $R = \min_{i,j}\{d_{ij}\} + \delta$ і при кожному повторенні збільшувати $\delta$ на невелику величину. Тоді можна виявити значення радіусів, що призводять до утворення однакової кількості класів, тобто до стійкого розбиття. \\ \\
"""
)

print(
    dataframe_to_latex_table(
        df.rename(index={j: f"$n_{{{i}}}$" for i, j in zip(range(10), df.index)}),
        left_top_item="Країна",
    )
)

print(r"Матриця відстаней має вигляд: ")

X = settings.task_10_classification_rows
Y = np.array([v - 1 for v in settings.task_10_classification_countries])

df = settings.task_10_table_raw

df_s = df.values
n = len(df)

std = df.std(ddof=1)

df_st = (df - df.mean()) / std

D = np.zeros((len(Y), len(Y)))
for i in range(len(Y)):
    for j in range(len(Y)):
        D[i][j] = np.sqrt(((df_st.loc[Y[i]] - df_st.loc[Y[j]]) ** 2).sum())

D = np.round(D, 2)
print(array_2d_to_latex(D, rounding=2))

print(r"\\\\")

R_max = 0
R_min = 1e9
D = np.zeros((len(Y), len(Y)))
for i in range(len(Y)):
    for j in range(len(Y)):
        D[i][j] = np.sqrt(((df_st.loc[Y[i]] - df_st.loc[Y[j]]) ** 2).sum())
        R_max = max(R_max, D[i][j])
        if D[i][j] != 0:
            R_min = min(R_min, D[i][j])

R = round((R_max + R_min) / 3, 2)

print(
    r"Зазначимо, що $R_H = "
    + f"{round(R_min, 2)}"
    + r",$ а $R_B =  "
    + f"{round(R_max, 2)}"
    + r".$ Візьмемо $R = "
    + f"{round(R, 2)}"
    + r"$, а за центр сфери – перший об’єкт.\\"
)

used = []
for i in range(10):
    used.append(False)
cl = []
start = [-1]
rs_p = set()
rs = set()
while 1:
    rs_p = rs.copy()
    rs.clear()
    if len(start) == 1:
        for i in range(10):
            if used[i] == False:
                start = df_st.loc[Y[i]].values
                break
    if len(start) == 1:
        break
    for i in range(10):
        if used[i] == False:
            if np.sqrt(((start - df_st.loc[Y[i]].values) ** 2).sum()) < R:
                rs.add(i)
    rss = []
    for i in rs:
        rss.append(i)

    if rs == rs_p:
        for i in rss:
            used[i] = True
        start = [-1]
        cl.append(rss)
    else:
        start = (df_st.loc[Y[rss]]).sum().values / len(rss)
    print(
        ", ".join([f'\\{{{", ".join([str(a) for a in arr])}\\}}' for arr in cl]), "\\\\"
    )

